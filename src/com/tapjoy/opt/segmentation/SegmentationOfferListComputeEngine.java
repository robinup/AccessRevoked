package com.tapjoy.opt.segmentation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.hadoop.hbase.KeyValue;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.log4j.Logger;

import com.tapjoy.opt.common.HBaseConn;
import com.tapjoy.opt.offerlist.CompoundRow;
import com.tapjoy.opt.offerlist.CompoundRow.CompoundRowNewCompare;
import com.tapjoy.opt.offerlist.OfferList;
import com.tapjoy.opt.offerlist.OfferListWithref;
import com.tapjoy.opt.resource.OfferListComputeEngine;
import com.tapjoy.opt.resource.ResourceDataContainer;
import com.tapjoy.opt.segmentation.config.Configuration;

public class SegmentationOfferListComputeEngine extends OfferListComputeEngine {

    private static Logger logger = Logger
            .getLogger(OfferListComputeEngine.class);

    public SegmentationOfferListComputeEngine(
            ResourceDataContainer dataContainer) {
        super(dataContainer);
    }

    @Override
    public boolean computeStaticSegments() {
        return false;
    }

    /**
     * Generate device-customized Offer list.
     */
    @Override
    public OfferList computeForDevice(String customizedKey,
            HashMap<String, String> request, OfferList staticOL) {

        // get segmentation information for current udid
        String udid = request.get("udid");
        HashMap<String, Float> segProb = getSegmentationScore(udid); // from
                                                                     // user-big
                                                                     // table
                                                                     // real
                                                                     // time

        HashMap<String, Float> seg_cvr = ((SegmentationResourceDataContainer) dataContainer).seg_score; // from
                                                                                                        // S3
                                                                                                        // and
                                                                                                        // cached!

        // -- Changqing: this is a new device or udid is null
        if (segProb == null)
            System.out.println("new device found!");

        // algo starts
        long startTS = System.nanoTime();

        // convert the static offer list (generated by 324) to a map: <String
        // offerid, CompoundRow offer>
        @SuppressWarnings("unchecked")
        List<CompoundRow> offers = (List<CompoundRow>) staticOL.getOffers();
        HashMap<String, CompoundRow> allOfferMap = new HashMap<String, CompoundRow>();

        HashSet<String> offerset = new HashSet<String>(); // keep track of
                                                          // offer ids with
                                                          // segmentation cvr
                                                          // estimation
        ArrayList<CompoundRow> updateOffers = new ArrayList<CompoundRow>();
        Iterator<CompoundRow> iter = offers.iterator();
        // traversal offer wall 324 and update score if we have cvr estimation
        // of this (seg,offer_id) on S3
        while (iter.hasNext()) {
            CompoundRow of = new CompoundRow(iter.next());
            // System.out.println("Segmentation: bid="+of.getBid()); //just a
            // test
            allOfferMap.put(of.id, of);
            Iterator<Entry<String, Float>> it = segProb.entrySet().iterator();
            float newscore = 0;
            while (it.hasNext()) {
                @SuppressWarnings("rawtypes")
                Map.Entry pairs = (Map.Entry) it.next();
                if (seg_cvr.containsKey((String) pairs.getKey() + "#" + of.id)) {
                    // prob * cvr * bid(wait for lei add this field)
                    newscore += ((Float) pairs.getValue())
                            * seg_cvr.get(pairs.getKey() + "#" + of.id)
                            * of.getBid();

                    offerset.add(of.id);
                }
            }
            // if newscore has been updated(we have estimation of cvr)
            if (newscore > 0) {
                of.resv = newscore; // don't overwrite the original score! that
                                    // will affect the display of other algos.
                                    // use resv- LJ 10/17
                updateOffers.add(of);
            }
        }
        Collections.sort(updateOffers, new CompoundRowNewCompare());
        Collections.reverse(updateOffers);

        // iterate the static offers again and append non-updated offers to the
        // updated offer wall
        iter = offers.iterator();
        while (iter.hasNext()) {
            CompoundRow of = iter.next();
            if (!offerset.contains(of.id)) {
                updateOffers.add(of);
            }
        }
        OfferList custormizedOfferList = new OfferListWithref(customizedKey,
                updateOffers, true);

        long endTS = System.nanoTime();

        logger.info("Finished real-time algo. Time used: " + (endTS - startTS)
                + " nanoseconds");

        return custormizedOfferList;
    }

    /**
     * Get user conversion history from HBase
     */
    private HashMap<String, Float> getSegmentationScore(String udid) {
        System.out.println("let's get segmentation prob from HBase");
        if (udid == null || udid.length() < 1) {
            return null;
        }

        Result res = HBaseConn.getOneRecordInTableWithTimeout(udid,
                ((SegmentationResourceDataContainer) dataContainer).rttoken,
                ((SegmentationResourceDataContainer) dataContainer).auxtables,
                Configuration.HBASE_TIMEOUT_THRES,
                Configuration.HBASE_TRAFFIC_TIME); // real-time query
                                                   // with pre-created
                                                   // table object

        if (res == null) {
            logger.info("udid " + udid + " HBase returns null");
            System.out.println("udid " + udid + " HBase returns null");
            return null;
        } else if (res.isEmpty()) {
            logger.info("udid " + udid + " HBase returns empty");
            System.out.println("udid " + udid + " HBase returns empty");
            return null;
        }
        HashMap<String, Float> segScores = new HashMap<String, Float>();
        for (KeyValue kv : res.raw()) {
            byte[] byteval = kv.getValue();
            String val = Bytes.toString(byteval);
            if (val == null || val.equals("null")) {
                continue;
            }
            System.out.println(val);
            String[] scores = val.split("#");
            for (int i = 0; i < scores.length; i++) {
                // System.out.print(scores[i]);
                if (scores[i].isEmpty())
                    continue;
                String[] oneSeg = scores[i].split(",");
                segScores.put(oneSeg[0], Float.valueOf(oneSeg[1]));
            }
            break;
        }
        return segScores;
    }
}
